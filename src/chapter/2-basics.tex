\chapter{Grundlagen}\label{ch:basics}

\section{Übungskonzept}\label{sec:programming-assignments}

\todo{
    Genauer Ablauf des Lebenszyklus einer Hausaufgabe.
    Personas von Studierenden und Bewertern.
}

\subsection{Ablauf}\label{subsec:workflow}

\todo{
    Konzeption, Punkteberechnung, Bearbeitung, Bewertung, Feedback.
}

\subsection{Studierende}\label{subsec:students}

\todo{
    Kreative Lösungsansätze oder Nachprogrammieren der Vorlesung.
}

\subsection{Betreuer}\label{subsec:teaching-assistants}

\todo{
    Viele Bewertungen am Stück oder nach und nach.
    Akribische Fehlersuche oder flüchtiges Betrachten.
}

\section{Technologien}\label{sec:tech}

\subsection{fulib.org}\label{subsec:fulib.org}

\todo{
    Screenshots?
}

fulib.org ist eine Webanwendung, die bereits 2019 im Rahmen von~\cite{explain} konzipiert und durch~\cite{bachelor-thesis} erweitert wurde.
Sie besteht aus einigen Modulen, die nachfolgend kurz beschrieben werden.

\paragraph{Scenarios}
Das erste Modul der Anwendung ist ein interaktiver Editor für die Szenario-Sprache aus~\cite{explain}.
Diese besteht aus textuellen Beispielszenarien, die einer festen Grammatik folgen.
Ein Compiler übersetzt die Szenarien in Java-Code und generiert dabei Klassen für ein Datenmodell mit~\cite{fulib}.
In~\cite{bachelor-thesis} wurde erstmals eine Erweiterung der Sprache umgesetzt, die gezielt die Bewertung von Aufgaben ermöglichen sollte.
Dafür wurde spezielle Syntax zur Mustererkennung auf Objektstrukturen entwickelt, die besonders für Fälle geeignet war, in der die Benennung von Variablen, Attributen und Assoziationen nicht festgelegt war.
Nachfolgend wird die Szenario-Sprache und der Editor auf fulib.org nicht weiter betrachtet.
Es handelt sich jedoch um wichtige Hintergründe und Erkenntnisse, die in den Abschnitten~\ref{sec:expanding-fulib.org} und~\ref{par:renaming-and-refactoring} wieder aufgegriffen werden.

\paragraph{Docs}
Hier kann die Dokumentation für verwandte Werkzeuge aus dem fulib-Toolkit nachgelesen werden.
Diese wird direkt von den jeweiligen GitHub-Repositories bezogen, ist also nicht Teil der Webanwendung selber.
Insbesondere befindet sich hier das Benutzerhandbuch von fulibFeedback.

\paragraph{Projects}
Dieser Teil der Webanwendung ist eine Prototyp für eine Online-\ac{ide}.
Dort können Projekte erstellt werden, die im Gegensatz zum Szenario-Editor mehrere Dateien umfassen können.
Insbesondere können hier Gradle- und Java-Dateien betrachtet und bearbeitet werden.
Ein Dateibaum zeigt Ordner und darin befindliche Dateien jeglicher Art.
Mit einem Web-Terminal können beliebige Kommandozeilenbefehle ausgeführt werden, darunter auch die zum Bauen und Ausführen verwendeten Gradle-Befehle.
Die Projekte ermöglichen folglich eine eingeschränkte Form der Anwendungsentwicklung in einer Desktop-\ac{ide}.
Nachfolgend werden Projekte nicht weiter eingesetzt, sie bieten sich jedoch für zukünftige Erweiterungen in Abschnitt~\ref{par:future-projects} an.

\paragraph{Assignments}
Das ursprünglich in~\cite{bachelor-thesis} entwickelte Assignments-Modul von fulib.org ist nun erneut Zentrum der Implementierung.
In Abschnitt~\ref{sec:expanding-fulib.org} wird vermehrt beleuchtet, welche Änderungen vorgenommen wurden.
Nun soll zunächst beschrieben werden, wie der Stand des Moduls gegen Ende von~\cite{bachelor-thesis} war.
Vor dieser Arbeit waren die Assignments, eine eigene Bezeichnung für Hausaufgabenblätter, nur auf Aufgaben in der Szenario-Sprache fokussiert.
Mit einfachen Formularen konnten Titel, Beschreibung, Abgabefrist und einige Teilaufgaben definiert werden.
Jede Teilaufgabe bestand mindestens aus Kurzbeschriebung und Punktzahl
Optional konnte eine Teilaufgabe mit Verifizierungscode in der Szenario-Sprache, meist mit der Pattern Matching-Syntax aus~\cite{bachelor-thesis}, ausgestattet werden.
Studierende erhielten nach erfolgreicher Erstellung des Assignments einen Einladungslink, unter dem sie eine Lösung hochladen konnten.
Diese bestand aus einem zusammenhängenden Szenario-Text.
Nach dem Absenden wurde für jede Teilaufgabe der Verifizierungscodes zusammen mit der Lösung ausgeführt.
Bei erfolgreicher Ausführung wurden für die Teilaufgabe volle Punktzahl, im Fehlerfall null Punkte vergeben.
Somit konnte eine Gesamtpunktzahl errechnet werden.

\subsection{Visual Studio Code}\label{subsec:visual-studio-code}

\ac{vsc}\footnote{\url{https://code.visualstudio.com/}} ist ein erweiterbarer Code-Editor von Microsoft.
Neben den Grundfunktionen eines Texteditors hat \ac{vsc} Funktionen zur Entwicklerproduktivitäts wie Syntax-Highlighting und Autovervollständigung.
Durch vorinstallierte Erweiterungen kann Versionsverwaltung mit Git verwendet werden.
Verschiedene Spracherweiterungen ermöglichen bessere Autovervollständigung und Semantisches Highlighting abhängig von Typinformationen sowie die Darstellung von Syntax-Fehlern und Warnmeldung im Quellcode.
Darüber hinaus ist die Anwendung beliebig mit Erweiterungen anpassbar, die aus einem von Microsoft bereitgestellten Marketplace bezogen werden können\footnote{\url{https://marketplace.visualstudio.com/VSCode}}.
Die Schnittstellen für Erweiterungen sind ausführlich dokumentiert und Entwickler können mit geringem Aufwand eigene Erweiterungen publizieren.
Für Spracherweiterung wirbt \ac{vsc} besonders mit dem \ac{lsp} (siehe~\ref{subsec:language-server-protocol}).
In Abschnitt~\ref{sec:fulibFeedback} wird dies genutzt, um die fulibFeedback-Erweiterung zu veröffentichen.

\todom{Vielleicht sollte das wo anders hin?}
\ac{vsc} wurde als Grundlage für diese Arbeit aus zwei Gründen gewählt.
Einerseits ist die Entwicklung von Erweiterungen im Vergleich zu der \ac{ide} IntelliJ IDEA deutlich einfacher, da die Logik mit dem \ac{lsp} wiederverwendbar implementiert werden kann.
IntelliJ IDEA bietet dafür keine eigene Unterstützung, stattdessen müssen Plugins von Dritten
\footnote{\url{https://github.com/gtache/intellij-lsp}}
\footnote{\url{https://github.com/lsp4intellij/intellij-lsp-plugin}}
\footnote{\url{https://github.com/ballerina-platform/lsp4intellij}}
verwendet werden.
Diese werden teilweise nicht weiterentwickelt, bieten nur eingeschränkte Funktionen des \ac{lsp}, oder sind nicht mit aktuellen Versionen von IntelliJ IDEA kompatibel.
Andererseits war \ac{vsc} ein vorgegebenes Werkzeug in der Veranstaltung "Programmieren und Modellieren" im Wintersemester 2021/22.
Es bot sich an, für die Bewertung die gleiche \ac{ide} zu benutzen wie die Studierenden zur Lösungserstellung.
Dadurch konnten bestimmte umgebungsabhängige Fehler vermieden werden.

\subsection{Language Server Protocol}\label{subsec:language-server-protocol}

Das \ac{lsp} bezeichnet eine von Microsoft entwickelte Spezifikation\footnote{\url{https://microsoft.github.io/language-server-protocol/}}, die ein Client/Server-Modell für Sprachunterstützung von Code-Editoren und ein zugehöriges Protokoll vorschlägt.
Das standardisierte Protokoll sollte einige Probleme lösen, die sowohl Entwicklern von Editoren als auch von Programmiersprachen bekannt waren.
Diese werden nachfolgend kurz erläutert.

\paragraph{Quadratischer Entwicklungsaufwand}
Im Vordergrund stand das Problem des quadratischen Entwicklungsaufwands ohne ein standardisiertes Protokoll.
Soll eine neue Programmiersprache Verwendung finden, ist es notwendig, Unterstützung in möglichst vielen Editoren zu implementieren.
Dies ist teilweise durch Plugins möglich, die von den Sprachautoren bereitgestellt werden können, aber mitunter signifikanten Entwicklungsaufwand benötigen.
Aus Sicht der Autoren hat jeder Editor andere Schnittstellen und Funktionen, die studiert und angebunden werden müssen.
Dies kann die Adaption von Sprachen bei begrenztem Entwicklungsbudget einschränken.
Aus Sicht der Editorautoren ergibt sich ein ähnliches Problem.
Um einen neuen Editor marktfähig zu machen, sollte dieser eine große Anzahl populärer Programmiersprachen unterstützen.
Diese können jedoch weitgehend unterschiedliche Schnittstellen und Werkzeuge bereitstellen, abhängig davon, ob die Editorunterstützung von den Sprachautoren bei der Konzeption von Compiler und anderen Tools eingearbeitet wurde.
Unter Umständen ist es notwendig, große Teile der Syntax und Semantik dieser Sprachen neu zu implementieren, um Editorunterstützung zu ermöglichen.
Mit dem \ac{lsp} wird dieses Problem aus Sicht beider Seiten gelöst.
Sprachautoren können einen Server bereitstellen, der gegen die Schnittstellen des \ac{lsp} entwickelt wird.
Der Editor kann beliebige Sprachserver über die gleichen Schnittstellen ansprechen.
\footnote{\url{https://code.visualstudio.com/api/language-extensions/language-server-extension-guide\#why-language-server}.\label{fn:why-lsp}}

\paragraph{Trennung von Technologien}
Ein weiterer Vorteil des \acp{lsp} ist die Möglichkeit, Server und Client in unterschiedlichen Programmiersprachen und Frameworks zu entwickeln.
Dies kann sprachseitig die Serverentwicklung vereinfachen, da beispielsweise Teile der Implementierung des Compilers wiederverwendet werden können.\footref{fn:why-lsp}

\paragraph{Trennung von Prozessen}
Zuletzt nennt Microsoft die Prozesstrennung als vorteilhaft, welche die parallele Ausführung von rechenintensiven Aufgaben erlaubt.\footref{fn:why-lsp}
Abhängig von der Architektur des Editors ist dies jedoch auch ohne ein solches Protokoll möglich.
\footnote{Beispielsweise in IntelliJ, das Vorgaben für Multithreading macht um schreibende Aktionen (Texteingabe, \ldots) von lesenden Aufgaben (Syntaxanalyse, Diagnostics, Highlighting, \ldots) zu trennen. \url{https://plugins.jetbrains.com/docs/intellij/general-threading-rules.html}}

Nachfolgend werden einige Editor-Funktionen beschrieben, die das \ac{lsp} anbietet.
Grundsätzlich sind weder Client noch Server von der Spezifikation verpflichtet, diese anzubieten.
Wird eine Editorfunktion von dem Server nicht unterstützt, so wird standardmäßig keine Aktion durchgeführt.
\footnote{\todo{Source? Steht nicht so richtig in der Spezifikation}}
Gleichermaßen kann der Server verschiedene Editoraktionen aufrufen, die nicht zwangsweise unterstützt werden müssen.
Beim Start des Servers wird aus diesem Grund kommuniziert, welche Funktionen beide Parteien bereitstellen.
\footnote{\url{https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/\#initialize}}

\todo{
    Einfache Implementierung von Diagnostics und Code Actions (später Selection).
}

\subsection{Elasticsearch}\label{subsec:elasticsearch}

\todo{
    Datenbank für Textsuche optimiert.
    Basiert auf Apache Lucene.
    Eigentlich für natürliche Sprache ausgelegt (N-Gramme, Stemming).
    Erweiterbar mit Custom Lexer.
}

\subsection{Sonstige}\label{subsec:other-libraries}

\todo{
    Angular, NestJS, Bootstrap, Bootstrap-Darkmode, Bibliotheken.
}
