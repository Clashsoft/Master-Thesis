\chapter{Auswertung}\label{ch:results}

Die Evaluation hat eine Vielzahl von Erkenntnissen und Daten geliefert, die nun ausgewertet werden.
Dabei wird zunächst auf die Zielsetzung aus Abschnitt~\ref{sec:goals} Bezug genommen.
Weiterhin werden die Forschungsergebnisse präsentiert, die Antworten auf die Forschungsfragen aus Abschnitt~\ref{sec:research-questions} liefern.

\section{Zielerfüllung}\label{sec:goals-reached}

Zu Beginn wurden einige Anforderungen und Rahmenbedingungen gestellt, welche die Software erfüllen sollte, die für diese Arbeit entwickelt wurde.
Diese werden an dieser Stelle abschließend überprüft.

\begin{description}
    \item[Optionale Benutzung und Integration bestehender Vorgänge.]
    Die unterstützende Rolle wird erfüllt, indem Lösungen automatisch importiert werden, die auf Knopfdruck im Editor geöffnet werden und die sofortige Bewertung erlauben.
    Vorherige Abläufe wie das manuelle Clonen von GitHub, Zusammenstellen von Feedback und Berechnung von Punkten wurden dadurch ersetzt.
    Die Verwendung der Werkzeuge ist gänzlich optional, sowohl für Studierende als auch Bewertende.
    Bestehende Abgabemechanismen wie GitHub Classroom bleiben erhalten und auch das Feedback kann weiterhin mit Issues oder anderen Mitteln eingereicht werden.
    Die Software unterstützt ferner den Import von Lösungen beliebiger Abgabesysteme in Form von Dateien sowie das Versenden von Feedback via Email oder Text.
    Damit wird die Integration beliebiger Plattformen ermöglicht.
    Bewertende, welche die Werkzeuge nicht verwenden möchten, können weiterhin auf bewährte Methoden zurückgreifen.
    Sie verzichten dabei jedoch auf die Vorteile von Code Search und sonstiger gesteigerter Produktivität.
    \item[Nachvollziehbarkeit.]
    Es ist möglich, Aufgaben bis auf einzelne Punkte zu definieren und dadurch detaillierte Statistiken zu ermitteln.
    Sie geben Einblick darüber, welche Teilaufgaben besonders häufig zu Fehlern führen.
    \item[Übergreifende Bewertung.]
    Mehrere Abgaben können durch Code Search gleichzeitig bewertet werden, wodurch wertvolle Bewertungszeit gespart wird.
    Die Übertragung von Bewertungen auf anderen Lösungen erfolgt sofort, sodass betroffene Bewertende keine vermeidbare Arbeit beginnen müssen.
    \item[Sicherheit.]
    Für die Code-Suche ist es nicht erforderlich, die abgegebenen Programme auszuführen.
    Damit wird die Sicherheit gegenüber schädlicher Software garantiert.
\end{description}

\section{Forschungsergebnisse}\label{sec:research-results}

Nachfolgend wird abschließend auf die vier Forschungsfragen eingegangen, die dank der umfangreichen Evaluation beantwortet werden konnten.

\subsection[\acs{rq}1]{\ac{rq}1: Kann die Bewertung von Programmieraufgaben sinnvoll automatisiert werden?}\label{subsec:ra1-useful-automation}

Die Verwendung von Code Search hat ergeben, dass die automatische Bewertung von Programmieraufgaben eindeutig möglich ist, wenn auch mit unterschiedlich guten Ergebnissen abhängig von der Aufgabenstellung.
An dieser Stelle sollte auch beachtet werden, dass die Arbeit sich nur auf Aufgaben spezialisiert hat, bei denen Programmcode geschrieben wird.
Die Quellcode-Suche wäre bei geeignetem Dateiformat, beispielsweise Textdateien, für andere Aufgaben einsetzbar.
Natürliche Sprache bietet jedoch wesentlich mehr Variationen in der Ausdrucksweise, als es bei Programmiersprachen der Fall ist.
Dies würde die Anwendbarkeit von Code Search erheblich einschränken.
Es ist sogar naheliegend, dass das Finden von ähnlichem Text auf ein Plagiat hindeutet.
Bei Veranstaltungen, deren Aufgaben hauptsächlich Quellcode erwarten, lohnt sich dennoch die Einrichtung der Werkzeuge, auch wenn einige Aufgaben in anderer Form gelöst werden.
Die Hausaufgaben 1, 2 und 5 der Veranstaltung "Programmieren und Modellieren" haben dies gezeigt.

\subsection[\acs{rq}2]{\ac{rq}2: Welcher Mehraufwand wird für die automatisierte Bewertung benötigt?}\label{subsec:ra2-additional-effort}

Für die Bewertung mit fulib.org ist zunächst nur die Einrichtung eines Assignments erforderlich, wie in Abschnitt~\ref{subsec:creating-assignments} beschrieben wurde.
Dies ist in wenigen Minuten möglich, sofern die Liste von Teilaufgaben bereits vorliegt.
Um den Prozess zu beschleunigen, wurde das Markdown-Format als Eingabemöglichkeit hinzugefügt, wodurch mit wenigen Anpassungen der gesamte Baum von Teilaufgaben hinterlegt werden kann.
Nach Anlegen des Assignments sind keine größeren Schritte mehr notwendig.
Bewertende können mit wenigen Klicks die notwendigen Einstellungen tätigen und der Ablauf der Bewertung kann in kurzer Zeit erklärt werden.
Es ist nicht erforderlich, eine Musterlösung bereitzustellen, da diese Rolle von der ersten richtigen Lösung eines Studierenden erfüllt wird.
Die Suche von Quellcode benötigt keine Einrichtung eines Compilers, da sie rein textueller Natur ist.
Auch die Bereitstellung von Tests ist nicht notwendig, sofern diese Teil der Aufgabenstellung sind oder die Einschätzung der Richtigkeit von Quellcode ohne Tests möglich ist.

\subsection[\acs{rq}3]{\ac{rq}3: Welche Effektivität und Effizienz kann von der Automatisierung erwartet werden?}\label{subsec:ra3-effectivity-efficiency}

Die Auswertung hat gezeigt, dass Effektivität und Effizienz eine breite Spanne von Werten annehmen können.
Bei Aufgaben, die keinen Programmieranteil haben, liegt diese bei 0\%.
Werte von bis zu 88\% konnten unter nahezu optimalen Bedingungen, wie es in der \ac{pm}-Hausaufgabe 4 der Fall war, beobachtet werden.
Die meisten Ergebnisse sind jedoch im Bereich 40\% bis 60\% zu finden.
Das bedeutet, dass bei einer durchschnittlichen Programmieraufgabe etwa die Hälfte der Kriterien bei einer ausreichend großen Studierendenanzahl automatisiert bewertet werden können.

Die Effizienz und damit die tatsächlich durch Verwendung der Werkzeuge eingesparte Zeit muss kritisch betrachtet werden, um sinnvolle Schlüsse zu ziehen.
Während die anhand der Telemetrie berechnete Effizienz mit Werten zwischen 54\% und 80\% erhebliche Zeitersparnisse verspricht, ergibt die angepasste Effizienz geringere Werte.
Wird die Zeit, die nicht direkt bei der Bewertung von Teilaufgaben, sondern in Oberflächen, beim Clonen, Testen und Ausprobieren von Anwendungen verbracht wird, in die Berechnung einbezogen, sinkt der Bereich auf 23\% bis 65\%.
Auch diese Werte sind abhängig von der Aufgabenstellung und dem generellen Arbeitsverhalten der Bewertenden.

Über die Veränderung der Metriken im Verlauf einer Veranstaltung oder über Semestergrenzen hinweg kann keine allgemeingültige Aussage getroffen werden.
Die Veranstaltungen \ac{pm} und \ac{algods} weisen ähnliche Werte in den zuvor genannten Metriken auf.
Im Verlauf der Hausaufgaben von \ac{pm} wurden zwei Anwendung begonnen und weiterentwickelt.
Während das Projekt von \ac{ha}4 bis 8 sinkende Effektivität aufweist, ist diese im zweiten Projekt von \ac{ha}9 bis \ac{ha}11 wieder angestiegen.

\subsection[\acs{rq}4]{\ac{rq}4: Wie können Aufgaben formuliert oder angepasst werden, um die Effektivität und Effizienz zu steigern?}\label{subsec:ra4-improve-effectivity-efficiency}

In der Veranstaltung \ac{pm} konnten einige Anpassungen an Aufgaben vorgenommen werden, die bessere Ergebnisse mit Code Search erzielt haben.
Die Vorgabe von Namen im Datenmodell und Methoden konnte sicherstellen, dass viele Studierende ähnlichen Code erzeugen.
Die hohe Effektivität von 88\% in \ac{ha}4 ist beispielsweise durch das vorgegebene Datenmodell und die damit verbundenen Teilaufgaben zur Verwendung von fulib entstanden.
Auch die Projekteinrichtung in \ac{ha}9 hat mit 78\% davon profitiert.
In \ac{ha}6 wurde ebenfalls ein hoher Wert von 81\% erreicht, da die \acp{id} vorgegeben waren, die zum Erstellen der \ac{fxml}-Dateien notwendig waren und somit Elemente der Oberfläche mit Code Search gesucht werden konnten.
Mit Vorlagen, welche die Struktur von Klassen und Methodenrümpfen festlegten, konnten in \ac{ha}7 und 8 trotz der komplexen Implementierungsaufgaben akzeptable Effektivitäts-Werte von 56\% \ac{bzw} 59\% erzielt werden.
Es ist jedoch zu beachten, dass diese Vorlagen das eigenständigen Entwerfen von Code unterdrücken und damit die Kreativität von Studierenden einschränken können.
